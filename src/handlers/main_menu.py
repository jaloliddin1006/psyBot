import logging
from aiogram import types
from aiogram.types import KeyboardButton, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.fsm.context import FSMContext
from src.database.session import get_session, close_session
from src.database.models import User
from src.constants import MAIN_MENU
from aiogram import Router, F
from aiogram.filters import Command
from .emotion_diary import start_emotion_diary

logger = logging.getLogger(__name__)
router = Router(name=__name__)

async def main_menu(source: types.Message | types.CallbackQuery, state: FSMContext) -> int:
    logger.info(f"main_menu invoked. Source type: {type(source)}, Source from_user.id: {source.from_user.id if source and hasattr(source, 'from_user') else 'N/A'}")
    actual_user: types.User
    answer_target: types.Message  # The object whose .answer() method we'll use
    message_to_potentially_delete_id: int | None = None

    if isinstance(source, types.Message):
        actual_user = source.from_user
        answer_target = source
        # This is the user's command message (e.g., /start) that we might want to delete
        message_to_potentially_delete_id = source.message_id
        logger.info(f"Entering main_menu from Message. User ID: {actual_user.id}, Message ID: {source.message_id}")
    elif isinstance(source, types.CallbackQuery):
        actual_user = source.from_user
        answer_target = source.message  # Reply to the message the button was on
        # The message with the button (source.message) is usually deleted by the callback handler itself
        logger.info(f"Entering main_menu from CallbackQuery. User ID: {actual_user.id}, CallbackQuery ID: {source.id}")
    else:
        logger.error(f"main_menu called with invalid source type: {type(source)}")
        # Optionally, try to reply with an error if possible, though answer_target is not set
        return MAIN_MENU # Or handle error appropriately

    data = await state.get_data()
    messages_to_delete = data.get('messages_to_delete', [])
    if messages_to_delete is None:
        messages_to_delete = []

    session = get_session()
    db_user = session.query(User).filter(User.telegram_id == actual_user.id).first()
    
    if db_user:
        logger.info(f"main_menu: Found db_user. ID: {db_user.id}, Telegram ID: {db_user.telegram_id}, Full Name: '{db_user.full_name}', Reg Complete: {getattr(db_user, 'registration_complete', 'N/A')}")
    else:
        logger.warning(f"main_menu: db_user not found for Telegram ID: {actual_user.id}")

    if not db_user or not getattr(db_user, 'registration_complete', False) or not db_user.full_name:
        logger.warning(f"main_menu: Registration incomplete or name missing. db_user: {bool(db_user)}, reg_complete: {getattr(db_user, 'registration_complete', 'N/A') if db_user else 'N/A'}, full_name: {db_user.full_name if db_user else 'N/A'} for User ID: {actual_user.id}")
        close_session(session)
        await answer_target.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é /start aas")
        return MAIN_MENU

    # Check trial status
    from src.trial_manager import check_trial_status, get_access_denied_message, has_feature_access
    trial_status, days_remaining = check_trial_status(db_user)
    
    # If trial expired, show expiry message and block access
    if trial_status == 'trial_expired':
        close_session(session)
        await answer_target.answer(get_access_denied_message('main_menu'))
        return MAIN_MENU

    name = db_user.full_name
    
    # Show trial status info if in trial
    trial_info = ""
    if trial_status == 'trial_active':
        trial_info = f"\nüéØ –ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥: –æ—Å—Ç–∞–ª–æ—Å—å {days_remaining} –¥–Ω–µ–π"
    elif trial_status == 'premium':
        trial_info = "\n‚≠ê –ü—Ä–µ–º–∏—É–º-–¥–æ—Å—Ç—É–ø –∞–∫—Ç–∏–≤–µ–Ω"
    
    close_session(session)
    
    current_fsm_state_data = await state.get_data()
    new_fsm_state_data = {'messages_to_delete': current_fsm_state_data.get('messages_to_delete', [])}
    await state.set_data(new_fsm_state_data)

    keyboard = [
        [KeyboardButton(text="–î–Ω–µ–≤–Ω–∏–∫ —ç–º–æ—Ü–∏–π")],
        [KeyboardButton(text="–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ —ç–º–æ—Ü–∏–π")],
        [KeyboardButton(text="–¢–µ–º—ã –¥–ª—è –ø—Ä–æ—Ä–∞–±–æ—Ç–∫–∏")],
        [KeyboardButton(text="–ú–µ—Ç–æ–¥—ã —Ä–µ–ª–∞–∫—Å–∞—Ü–∏–∏")],
        [KeyboardButton(text="–†–µ—Ñ–ª–µ–∫—Å–∏—è –≤—Å—Ç—Ä–µ—á–∏ —Å –ø—Å–∏—Ö–æ—Ç–µ—Ä–∞–ø–µ–≤—Ç–æ–º"), KeyboardButton(text="–ù–∞ –≥–ª–∞–≤–Ω—É—é")]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)
    
    logger.info(f"main_menu: Sending main menu to {name} (User ID: {actual_user.id})")
    sent_menu_message = await answer_target.answer(
        f"–ü—Ä–∏–≤–µ—Ç, {name}!{trial_info}\n\n–ß—Ç–æ –±—ã —Ç—ã —Ö–æ—Ç–µ–ª–∞ —Å–¥–µ–ª–∞—Ç—å: –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ—é —ç–º–æ—Ü–∏—é –∏–ª–∏ –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏—è–º–∏ –ø–æ—Å–ª–µ —Å–µ—Å—Å–∏–∏ —Å –ø—Å–∏—Ö–æ—Ç–µ—Ä–∞–ø–µ–≤—Ç–æ–º?\n\n –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –æ–±—Å—É–¥–∏—Ç—å —á—Ç–æ-—Ç–æ –∏–ª–∏ —Ä–∞–∑–æ–±—Ä–∞—Ç—å –∫–∞–∫—É—é-–ª–∏–±–æ —Å–∏—Ç—É–∞—Ü–∏—é, —è –≥–æ—Ç–æ–≤ —Ç–µ–±–µ –ø–æ–º–æ—á—å –≤ —ç—Ç–æ–º. –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –º–Ω–µ ‚ò∫Ô∏è",
        reply_markup=reply_markup
    )
    
    messages_to_delete_updated = (await state.get_data()).get('messages_to_delete', [])
    if messages_to_delete_updated is None: messages_to_delete_updated = []
    
    messages_to_delete_updated.append(sent_menu_message.message_id)
    
    # If main_menu was triggered by a direct user message (like /start), add that message for deletion
    if message_to_potentially_delete_id and message_to_potentially_delete_id not in messages_to_delete_updated:
        messages_to_delete_updated.append(message_to_potentially_delete_id)

    await state.update_data(messages_to_delete=messages_to_delete_updated)
    logger.info(f"main_menu: Updated messages_to_delete: {messages_to_delete_updated} for User ID: {actual_user.id}")
    
    return MAIN_MENU

@router.message(F.text == "–î–Ω–µ–≤–Ω–∏–∫ —ç–º–æ—Ü–∏–π")
async def handle_emotion_diary_button(message: types.Message, state: FSMContext):
    logger.info(f"Handling '–î–Ω–µ–≤–Ω–∏–∫ —ç–º–æ—Ü–∏–π' button press. message.from_user.id: {message.from_user.id}")
    
    # Check access permissions
    session = get_session()
    try:
        db_user = session.query(User).filter(User.telegram_id == message.from_user.id).first()
        if not db_user:
            await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é /start")
            return
        
        from src.trial_manager import has_feature_access, get_access_denied_message
        if not has_feature_access(db_user, 'emotion_diary'):
            await message.answer(get_access_denied_message('emotion_diary'))
            return
    finally:
        close_session(session)
    
    await start_emotion_diary(message, state)

@router.message(F.text == "–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ —ç–º–æ—Ü–∏–π")
async def handle_emotion_analysis_button(message: types.Message, state: FSMContext):
    logger.info(f"Handling '–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ —ç–º–æ—Ü–∏–π' button press. message.from_user.id: {message.from_user.id}")
    
    # Check access permissions
    session = get_session()
    try:
        db_user = session.query(User).filter(User.telegram_id == message.from_user.id).first()
        if not db_user:
            await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é /start")
            return
        
        from src.trial_manager import has_feature_access, get_access_denied_message
        if not has_feature_access(db_user, 'emotion_analytics'):
            await message.answer(get_access_denied_message('emotion_analytics'))
            return
    finally:
        close_session(session)
    
    from .emotion_analysis import start_emotion_analysis
    await start_emotion_analysis(message, state)

@router.message(F.text == "–¢–µ–º—ã –¥–ª—è –ø—Ä–æ—Ä–∞–±–æ—Ç–∫–∏")
async def handle_therapy_themes_button(message: types.Message, state: FSMContext):
    logger.info(f"Handling '–¢–µ–º—ã –¥–ª—è –ø—Ä–æ—Ä–∞–±–æ—Ç–∫–∏' button press. message.from_user.id: {message.from_user.id}")
    
    # Check access permissions
    session = get_session()
    try:
        db_user = session.query(User).filter(User.telegram_id == message.from_user.id).first()
        if not db_user:
            await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é /start")
            return
        
        from src.trial_manager import has_feature_access, get_access_denied_message
        if not has_feature_access(db_user, 'therapy_themes'):
            await message.answer(get_access_denied_message('therapy_themes'))
            return
    finally:
        close_session(session)
    
    from .therapy_themes import start_therapy_themes
    await start_therapy_themes(message, state)

@router.message(F.text == "–ú–µ—Ç–æ–¥—ã —Ä–µ–ª–∞–∫—Å–∞—Ü–∏–∏")
async def handle_relaxation_methods_button(message: types.Message, state: FSMContext):
    logger.info(f"Handling '–ú–µ—Ç–æ–¥—ã —Ä–µ–ª–∞–∫—Å–∞—Ü–∏–∏' button press. message.from_user.id: {message.from_user.id}")
    
    # Check access permissions
    session = get_session()
    try:
        db_user = session.query(User).filter(User.telegram_id == message.from_user.id).first()
        if not db_user:
            await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é /start")
            return
        
        from src.trial_manager import has_feature_access, get_access_denied_message
        if not has_feature_access(db_user, 'relaxation_methods'):
            await message.answer(get_access_denied_message('relaxation_methods'))
            return
    finally:
        close_session(session)
    
    from .relaxation import start_relaxation_methods
    await start_relaxation_methods(message, state)

@router.message(Command("hotline"))
async def hotline_handler(message: types.Message, state: FSMContext) -> None:
    hotline_number = "+7 495 625-31-01"
    text = f"–¢–µ–ª–µ—Ñ–æ–Ω –≥–æ—Ä—è—á–µ–π –ª–∏–Ω–∏–∏: {hotline_number}\n–í—ã –º–æ–∂–µ—Ç–µ –ø–æ–∑–≤–æ–Ω–∏—Ç—å –ø–æ —ç—Ç–æ–º—É –Ω–æ–º–µ—Ä—É –≤ —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏."
    await message.answer(text)

@router.message(Command("help"))
async def help_handler(message: types.Message, state: FSMContext) -> None:
    keyboard = [
        [InlineKeyboardButton(text="–ö–∞–∫–∏–µ –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏", callback_data="help_features")],
        [InlineKeyboardButton(text="–ö–∞–∫ –æ–Ω –æ—Ç–≤–µ—á–∞–µ—Ç", callback_data="help_how_answers")]
    ]
    reply_markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å:", reply_markup=reply_markup)

@router.callback_query(F.data.startswith("help_"))
async def help_callback_handler(callback: types.CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    if callback.data == "help_features":
        await callback.message.edit_text("–ë–æ—Ç –º–æ–∂–µ—Ç –≤–µ—Å—Ç–∏ –¥–Ω–µ–≤–Ω–∏–∫ —ç–º–æ—Ü–∏–π, –ø–æ–º–æ–≥–∞—Ç—å —Å —Ä–µ—Ñ–ª–µ–∫—Å–∏–µ–π –ø–æ—Å–ª–µ —Å–µ—Å—Å–∏–∏ —Å –ø—Å–∏—Ö–æ—Ç–µ—Ä–∞–ø–µ–≤—Ç–æ–º, –¥–∞–≤–∞—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –∏ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –≤–∞—à –æ–ø—ã—Ç. (–ó–¥–µ—Å—å –≤–∞—à –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ç–µ–∫—Å—Ç)")
    elif callback.data == "help_how_answers":
        await callback.message.edit_text("–ë–æ—Ç –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –≤–∞—à–∏ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É—è –≤–∞—à –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –æ–ø—Ü–∏–∏. (–ó–¥–µ—Å—å –≤–∞—à –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ç–µ–∫—Å—Ç)")

@router.message(F.text == "–†–µ—Ñ–ª–µ–∫—Å–∏—è –≤—Å—Ç—Ä–µ—á–∏ —Å –ø—Å–∏—Ö–æ—Ç–µ—Ä–∞–ø–µ–≤—Ç–æ–º")
async def reflection_with_psychotherapist_handler(message: types.Message, state: FSMContext) -> None:
    # Check access permissions
    session = get_session()
    try:
        db_user = session.query(User).filter(User.telegram_id == message.from_user.id).first()
        if not db_user:
            await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é /start")
            return
        
        from src.trial_manager import has_feature_access, get_access_denied_message
        if not has_feature_access(db_user, 'reflection'):
            await message.answer(get_access_denied_message('reflection'))
            return
    finally:
        close_session(session)
    
    from .reflection import start_reflection
    await start_reflection(message, state)

@router.message(F.text == "–ù–∞ –≥–ª–∞–≤–Ω—É—é")
async def to_main_menu_handler(message: types.Message, state: FSMContext) -> None:
    await main_menu(message, state)